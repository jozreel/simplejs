var net = require('http');
var config = require('simple').config;
var buff = require('buffer').Buffer;
var url = require('url');
 var sockets = require('sockets');
var websocket = function(req,socket,head)
{
    //socket._readableState.highWaterMark =8000000;
          
	this.req = req;
	this.socket = socket;
	this.head = head;
	var obj = this;
	this.socket.on('data', function(data){obj.onData(data);});
	this.socket.on('close', function(ev){obj.onclose(ev)});
    this.socket.on('error', function(err){console.log(err);});
    this.socket.on('end', function(){console.log('end');});
    this.cont = false;
    this.messegeEnd = false;
  //  this.socket.on('connection', function(){obj.onconnect()});
	/*/this.req.on('upgrade', function(res, socket, upgradeHead) {
    console.log('got upgraded!');
    socket.end();
    process.exit(0);
	this.bigLenght = 0;
	
  });*/
 
	this.continiousData = [];
    this.iscont ='text';
	this.appid = "";
	this.user='';
	this.params=[];
    this.rawdata=[];
    
    
}

websocket.prototype.upgrade = function(receive, send)
{
	
	     
	      var trmd = this.req.headers['sec-websocket-key'].trim();
		  var crypto =require('crypto');
			var crypt = crypto.createHash('sha1').update(trmd+'258EAFA5-E914-47DA-95CA-C5AB0DC85B11').digest('base64');
			
			var respns = 'HTTP/1.1 101 Switching Protocols\r\n'+
                          'Upgrade: websocket\r\n'+
                           'Connection: Upgrade\r\n'+
                            'Sec-WebSocket-Accept: '+crypt+ '\r\n'+
							'\r\n';
	  this.pingpong();
	   this.socket.write(respns,function(err)
	   {
		   if(err)
		     console.log(err);});
	   
	   //this.socket.pipe(this.socket);
	   try{
		var urlparts = url.parse(this.req.url,true);
		
		var pathnm = urlparts.pathname.slice(1);
		
	
		var arrurl = pathnm.split('/');
	    var  quer = urlparts.query;
		
		 
		
		 var ctrl = arrurl[0];
		 arrurl.shift();
		
		 this.receiver = arrurl[0]; 
		 arrurl.shift();
		 
		 arrurl = arrurl.map(function(x){return websocket.replaceSpecial(x);});
		 if(arrurl.length > 0)
		    this.params = arrurl;
		// this.reciever = arrurl[1];
         if(ctrl !== '')
         {
	     var reslv = require.resolve('../application/controller/'+ctrl);
		 var ctr = require('../application/controller/'+ctrl);
		 this.controler = ctr;
		 this.controler.req.requestdata = quer;
         
		 ctr.socket = this.socket;
		 ctr.setSocket(this.socket);
         }	
		
		//var ext = path.extname(reslv);
		//var fn = path.basename(reslv.slice(0,-ext.length));
		//ctr = require('../application/controller/'+fn);
	   }
	   catch(err)
	   {
		   console.log(err);
	   }
	   
}

websocket.replaceSpecial = function(txt)
{
	
	//console.log(txt);
	return txt.replace(/&/g, '&amp;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');

}

websocket.prototype.onData=function(data)
{
     console.log(this.socket.bufferSize,'bfsize'); 
	
	this.readMessage(data);
}

websocket.prototype.readMessage = function(data)
{
  
	var next = 2;
	var key =[];
	//this.iscont ='text';
	var senddata='';
	var length=0;
	var FIN = (data[0] & 0x80);
    var RSV1 = (data[0] & 0x40);
     var RSV2 = (data[0] & 0x20);
     var RSV3 = (data[0] & 0x10);
	 var mask = (data[1] & 0x80);
	 var Opcode = data[0]& 0x0F;
    // console.log(data.byteLength, 'll', Opcode,FIN);
	// console.log(Opcode, FIN);
		//console.log(Opcode,FIN, this.continiousData.length,'control');
   // console.log(data[1],mask);
   var l = (data[1] & 0x7F);;
    if(mask !==0)
    var ln=0;
    if(mask===0)
    {
        ln = data[1];
        
    }
    else{
        ln = data[1] - 128;
    }
    
	if(l <= 125 )
    {
      if(mask !==0)
	    length = data[1] - 128;
      else
        length =data[1];
      length = Math.abs(length);
     // console.log(length);
      console.log(length,'small',Opcode,FIN);
    }
	else if(l === 126)
	{
		next+= 2;
        length = data.readUInt16BE(2);
		//length = (data[2] & 0xFF) << 8 | (data[3] & 0xFF);
        length = Math.abs(length);
        
        console.log(length,'med',Opcode,FIN);
        //console.log(length);
      //  console.log(length,mask);
        //console.log(length,'medium');
	}
	else if(l ===127)
	{  
		
		// var arr1 = ((data[2] & 0xFF) << 24  | (data[3] & 0xFF) <<16 | (data[4] & 0xFF) << 8 | data[5] & 0xFF) |  ((data[6] & 0xFF) <<24 | (data[7] & 0xFF) <<16 | (data[8] & 0xFF) <<8 | data[9] & 0xFF);
		//var arr1 = ((data[2] & 0xFF) << 56  | (data[3] & 0xFF) <<48 | (data[4] & 0xFF) << 40 | (data[5] & 0xFF)<<32 |  (data[6] & 0xFF) <<24 | (data[7] & 0xFF) <<16 | (data[8] & 0xFF) <<8 | data[9] & 0xFF);
		 hb = data.readUInt32BE(2);
         if(hb !== 0)
           return;
         length = data.readUInt32BE(6);
		//console.log(l,'newl');
	     // var arr2=   ((data[6] & 0xFF) <<24 | (data[7] & 0xFF) <<16 | (data[8] & 0xFF) <<8 | data[9] & 0xFF);
		  
    	  length = Math.abs(length); //+ arr2;
         // console.log(arr1);
         console.log(length,'big',Opcode,FIN);
         next+=8;
         
	}
    
    if(Opcode === 1   &&  this.continiousData.length ===0)
	          this.iscont = 'text';
    if(Opcode === 2  && this.continiousData.length ===0)
	          this.iscont = 'bin';
    if(this.continiousData.length === 0 && FIN === 0 && Opcode <=2 && Opcode >0)
    {
        
       this.cont = true;
    }
    if(this.continiousData.length === 0 && FIN !== 0 && Opcode <=2 && Opcode >0)
    {
        
       this.cont = false;
    }
    
   var decoded
   

	if(mask)
	{
	  key = data.slice(next, next + 4)
     // console.log('key',key)
	  next += 4;
	}
   
	if(Opcode ===1 || Opcode ===2||Opcode === 0)
	{
    
	var loops =1;
    if(length > 65535)
	  loops = Math.ceil(length/65535);
	 var message = data.slice(next,next+length);
    //console.log(message.length);
	// console.log(length);
	try{
      
	  decoded = new buff(message.length);
     }
     catch(er)
     {
        console.log(err);
        // return;
     }  
    
	for (var i = 0; i <  message.length; i++) {
		
       decoded[i] =  (message[i] ^ key[i % 4]);
      }     
			if(((Opcode === 1 || Opcode ===2) && this.cont === false)  || (this.cont === true && Opcode===0) || ((Opcode === 1 || Opcode ===2) && this.continiousData.length === 0) )
			{  if(this.cont ===true  && this.continiousData.length >0 && (Opcode !== 0))
                  ;// return;
             //  if(this.cont ===true  && this.continiousData.length >0 && (this.iscont === 'text' && Opcode !== 1))
                 //return;
               // console.log(this.cont,'mem',Opcode,FIN,this.iscont,length);
                //console.log(decoded.length);
				if(decoded.length !==0)
                {
			     this.continiousData.push(decoded); 
                 this.rawdata.push(message);
                }
				
			}
            
            
			    var b;
                var rd;
			   if(((this.iscont ==='text' || this.iscont === 'bin') && (this.cont === false && FIN!==0) ) ||((this.iscont ==='text' || this.iscont === 'bin') && (this.cont === true && Opcode ===0 && FIN!==0 )) )
			     {
                 
			      b =buff.concat(this.continiousData);
                 // console.log(b.length, 'length of data');
				  this.continiousData =[];
                  rd=buff.concat(this.rawdata);
                  this.rawdata=[];
                  this.cont=false;
                  this.messegeEnd = true;
				 }
                 
                 
                 
			// console.log(this.messegeEnd,FIN,this.iscont);
			  if(FIN!==0 && this.iscont==='text' && this.messegeEnd ===true)
			  {
                  this.messegeEnd = false;
                  this.iscont = '';
                //  console.log('abcd',Opcode);
				  if(b !== undefined)
                  {
                    var obj;
                   try{
				       obj= JSON.parse(b.toString('ascii'));
                       //console.log(obj);
                   }
                   catch(ex)
                   {
                       console.log(ex)
                     //  return;
                   }
                   var tosock;
                   if(obj !== undefined)
                    tosock= obj.touser;
				   //console.log(obj);
                   if(obj !== undefined)
                   {
				   if(obj.message_type == "HANDSHAKE")
				   {
					  
					  // this.user = obj.user !== undefined ? obj.user:'guest'+sockets.length;
					   this.appID = obj.appID;
					   if(obj.user !==undefined)
					    {
						  sockets[obj.user] =  this;
						  this.socket.user = obj.user;
						  this.user = obj.user;
						}
					  else
					   {
                        
                        this.user = 'guest'+Object.keys(sockets).length;
					    sockets['guest'+ Object.keys(sockets).length] = this;
						 
						 this.socket.user = this.user;
                         
                         
					   }
						
					 senddata={user:this.user,message:'connected',appID:obj.appID, message_type:obj.message_type}
						
					//console.log(sockets);
				   }
				  else if(obj.message_type == "DISCONECT")
				   {
					   this.socket.end();
				   }
                   else if(obj.message_type == "pong")
				   {   console.log('ponger');
					   this.socket.pingssent = 0;
				   }
                   else
                   {
				// vat temp = this.params;
                  // console.log(obj.message[0]);
				  this.params.unshift();
                 
				  senddata = {user:this.user,message:obj.message,appID:obj.appID, message_type:obj.message_type}
			      this.controler[this.receiver].apply(this.controler,this.params);
				  this.params.splice(0,1);
                   }
                   }
                   
                   if(tosock !== undefined)
                     {
                        tosoc = sockets[tosock];
                        
                         if(tosoc !==undefined)
                         {
                             
                           if(Object.keys(senddata).length >0)
                           {
                           
                            tosoc.sendData(JSON.stringify(senddata));
                            
                             }
                         }
                    }
                   if(obj.message_type !== 'PCP')
                    this.sendData(JSON.stringify(senddata));
                   
              }
              //this.iscont = 'text';
			  }
			   else if (FIN !==0 && this.iscont==='bin' && this.messegeEnd ===true)
			   {
                   //console.log(this.iscont,'jojo');
                   this.messegeEnd = false;
                   this.iscont = '';
                 // console.log('opc');
                  //senddata = {user:this.user,message:'hello', message_type:'blob'}
				//console.log(Opcode,'bin');
                //console.log(b.toString());
               
                try{
                    
                   // bs = filterUnicode(b.toString());
                   // bs = b.toString());
                    
                   //if(b.length >0)
                     //console.log(b);
                    senddata = b;//..{message:bs,message_type:'binary'};
                    
                      tosock = sockets['guest1']
                      if(tosock !== undefined)
                      {
                      tosoc = tosock;//sockets[tosock];
                          if(tosoc !==undefined)
                             {
                                 tosoc.sendData(senddata,null,'binary');
                    //this.iscont = 'text';
                               }
                      }
                }
                catch(er)
                {
                    console.log(er);
                }
                
				//this.params.unshift(b.toString('binary'));
			   // this.controler[this.receiver].apply(this.controler,this.params);
			   }
               
               
               
	}


}

websocket.prototype.sendData = function(message, socket,type)
{
  
    if(type === undefined)
      type= 'string';
	var reservedBytes = [];
	reservedBytes[0]=129;
	var length = message.length;
  //  console.log(length);
	var startdata = 2;
	if(length <=125)
	{
		reservedBytes[1]=length;
	}
	else if(length >=126 && length <= 65535)
	{
		reservedBytes[1]=126;
		reservedBytes[2] = (length >>8) & 0xFF;
		reservedBytes[3] = (length & 0xFF);
		
		startdata = 4;
		
	}
	else
	{
       
		reservedBytes[1]=127;
		reservedBytes[2] = (length >> 56) & 0xFF;
		reservedBytes[3] = (length >> 48) & 0xFF;
		reservedBytes[4] = (length >> 40) & 0xFF;
		reservedBytes[4] = (length >> 32)& 0xFF;
		reservedBytes[6] = (length >> 24) & 0xFF;
		reservedBytes[7] = (length > 16) & 0xFF;
		reservedBytes[8] = (length >> 8) & 0xFF;
		reservedBytes[9] = (length & 0xFF);
		startdata = 10;
		
		
	}
    
    if(type === 'string')
    {
     if(message.length > 0)
     {
	 for (var i = 0; i < message.length; i++){
        reservedBytes.push(message.charCodeAt(i));
    }
    
	//console.log(reservedBytes);
    try{
   // var bf = new buff(reservedBytes.toString());
	//console.log(reservedBytes);
	//this.controler[this.sender]()
   
   //console.log(message.length);
	this.socket.write(new buff(reservedBytes));
    }
    catch(er)
    {
        console.log(er);
    }
     }
    }
    else if(type === 'binary')
    {
        //var length = reservedBytes.length + message.length;
        //rbbuf  = new Buffer(length);
        
       reservedBytes[0]=130;
        //message = message.toString;
      // console.log(message.length);
        if(message.length > 0)
        {
           // msg = filterUnicode(message)
            
            try
            {
               
                //message= message.toString('binary');
               // console.log(message);
                // console.log(message[0]);
               // console.log(message[0].toString('binary'));]
               //message = message.toString();
               //console.log(message.toString('binary'));
               
               mbuff = new Buffer(message.length)
               
               // for(i=0;i<message.length;i++)
                //{ 
                 //   mbuff[i] = message[i];
                    //console.log(message.readUInt8(i));
                  // reservedBytes.push(message.charCodeAt(i));
                   // console.log(j);
                  //  console.log(message.readUInt8(i))
                  //console.log(message.toString('binary').charCodeAt(i));
                   //rbbuf.writeUInt8(message.readUInt8(j),i);
                //}
               // mbuff.write(message)
                //console.log(mbuff);
                rbbuf  = new Buffer(reservedBytes);
               // rbbuf.writeUInt8(0x2, 0);
            //   mbb = new Buffer(mbuff);
               
                newbuf = buff.concat([rbbuf,message]);
                //onsole.log(rbbuf);
             // reservedBytes[startdata]=abuff;
            //console.log(uiea.length);
            
            //if(reservedBytes.length <10)
            // console.log(message.length,'rlength');
            //reservedBytes.push(message);
            
          // console.log(reservedBytes);
           // console.log('i and i');
            this.socket.write(newbuf); 
            }
            catch(error)
            {
                console.log(error);
            }
        }
        else
        { 
           // return;
              //reservedBytes.push(72);
            //this.socket.write(new buff(reservedBytes));
        }
    }
	
}


var escapable = /[\x00-\x1f\ud800-\udfff\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufff0-\uffff]/g;

function filterUnicode(quoted){

  escapable.lastIndex = 0;
  if( !escapable.test(quoted)) return quoted;

  return quoted.replace( escapable, function(a){
    return '';
  });
}


websocket.prototype.onclose = function(ev)
{
	
    sockets[this.user] ={}
	delete sockets[this.user];
    console.log(ev);
	console.log('closed');
   // console.log(Object.keys(sockets).length,this.user);
	
}

websocket.prototype.pingpong = function()
{
    
    var obj = this;
    console.log('a websocket connection has opened');
    this.socket.pingssent = 0;
    var interval = setInterval(function() {
        if (obj.socket.pingssent >= 2) {// how many missed pings you will tolerate before assuming connection broken.
            obj.socket.destroy();
        } else {
            obj.sendData(JSON.stringify({message_type:'ping'}));
            obj.socket.pingssent++;
        }
    }, 60*1000);// 60 seconds between pings
   
}


module.exports = websocket;
